================================================================================
QUANTUM CONSCIOUSNESS PROGRAMMING LANGUAGE - SLUT 101
A Beginner's Guide to .slut Programming
================================================================================

TABLE OF CONTENTS
-----------------
1. Introduction
2. Basic Structure
3. Language Features
4. Variables and Data Types
5. Mathematical Problem Solving
6. Functions and Polymorphism
7. String Interpolation
8. Complete Examples
9. Running Your Programs
10. Tips and Best Practices

================================================================================
1. INTRODUCTION
================================================================================

The Quantum Consciousness Programming Language (.slut files) is a unique
domain-specific language that combines:
- Mathematical problem-solving
- Dynamic function generation
- Variable management with persistent state
- Consciousness/quantum metaphors for poetic programming

File Extension: .slut
Transpiler Binary: quantum (or quantum_slut_transpiler)

================================================================================
2. BASIC STRUCTURE
================================================================================

Every .slut program follows this structure:

```
* <main> ClassName {
    ^ observe_execution {
        [your code here]
    }
}
```

Breaking it down:
- `*` declares a class/function
- `<main>` marks the entry point (required)
- `ClassName` is the name of your main class
- `^ observe_execution` is the execution block
- All statements go inside the inner braces

Example:

```
* <main> HelloWorld {
    ^ observe_execution {
        speak("Hello, Quantum World!")
    }
}
```

================================================================================
3. LANGUAGE FEATURES
================================================================================

3.1 OUTPUT - speak()
--------------------
Print messages to the console.

Syntax:
    speak("Your message here")

Example:
    speak("The quantum state has collapsed!")

3.2 OUTPUT - woof
-----------------
Print a variable's value and its source equation.

Syntax:
    woof variableName

Example:
    x <> 42
    woof x

Output: "Final result: 42"

================================================================================
4. VARIABLES AND DATA TYPES
================================================================================

4.1 Direct Assignment
---------------------
Syntax:
    variableName <> value

Examples:
    age <> 25
    name <> "Katie"
    isActive <> true

Data Types:
- Numbers: 42, 3.14, -17
- Strings: "text" (in quotes)
- Booleans: true, false

4.2 User Input - userIn()
--------------------------
Get input from the user at runtime.

Syntax:
    variableName <> userIn("prompt message")

Example:
    name <> userIn("What is your name?")
    speak("Hello, ~name~!")

4.3 Calculation - calc()
-------------------------
Add numbers together (supports 2+ parameters).

Syntax:
    result <> calc(num1, num2, ...)

Examples:
    sum <> calc(10, 20)           # sum = 30
    total <> calc(5, 10, 15)      # total = 30

Can mix variables and literals:
    x <> 5
    y <> 10
    sum <> calc(x, y, 20)         # sum = 35

4.4 Random Choice - randomChoice()
-----------------------------------
Pick a random value from a list.

Syntax:
    variableName <> randomChoice([option1, option2, ...])

Examples:
    number <> randomChoice([1, 2, 3, 4, 5])
    color <> randomChoice(["red", "blue", "green"])

Can mix variables:
    x <> 10
    y <> 20
    choice <> randomChoice([x, y, 30])

================================================================================
5. MATHEMATICAL PROBLEM SOLVING
================================================================================

The most powerful feature: find equations that produce a target number!

5.1 Target-Seeking Mathematics
-------------------------------
Syntax:
    variableName([targetNumber]) <> randomChoice([availableNumbers])

The system will search through thousands of mathematical operations to find
an equation using the available numbers that equals (or approximates) the
target number.

Examples:

Example 1: Simple Target
    result([24]) <> randomChoice([3, 4, 2])

    System finds: 3 * 4 * 2 = 24
    Accuracy: 100%

Example 2: Complex Target
    answer([100]) <> randomChoice([5, 5, 3, 1])

    System might find: (5 + 5) * (3 + 1) = 40 (not exact)
    Or: 5 * 5 * 3 + 1 = 76 (closer)

Example 3: Using Variables
    target <> 48
    num1 <> 6
    num2 <> 8
    solution([target]) <> randomChoice([num1, num2])

    System finds: 6 * 8 = 48

5.2 How It Works
----------------
The system:
1. Generates all possible operations (+, -, *, /, ^, %, max, min, etc.)
2. Tries 2-number and 3-number combinations
3. Searches in parallel for speed
4. Caches successful solutions for future use
5. Returns the best match found

Operations supported:
- Basic: +, -, *, /
- Power: ^ (exponent)
- Modulo: %
- Advanced: max(), min(), hypot(), atan2()
- Grouping: (a + b) * c, etc.

================================================================================
6. FUNCTIONS AND POLYMORPHISM
================================================================================

6.1 Defining Functions
-----------------------
Create reusable functions that can have multiple variants.

Syntax:
    functionName(params) <> function(type)

Function Types:
- loop: Creates loop functions
- conditional: Creates conditional functions

Example:
    myLoop(params) <> function(loop)
    myCondition(params) <> function(conditional)

6.2 Executing Functions
------------------------
Run a function with parameters and a body.

Syntax:
    functionName(params)("body code")

Examples:

Count-based loop:
    myLoop(params) <> function(loop)
    myLoop(5)("console.log('Iteration')")

Range-based loop:
    myLoop(1, 10)("console.log('Number')")

Step-based loop:
    myLoop(0, 100, 10)("console.log('Step')")

6.3 Function Classes (Advanced)
--------------------------------
Define separate classes for reusable functions.

Structure:
```
* FunctionName {
    ^ observe_execution {
        [function code]
        woof returnValue
    }
}

* <main> MainClass {
    ^ observe_execution {
        result <> FunctionName()
    }
}
```

Example:
```
* Calculator {
    ^ observe_execution {
        x <> 10
        y <> 20
        sum <> calc(x, y)
        woof sum
    }
}

* <main> Program {
    ^ observe_execution {
        answer <> Calculator()
        speak("Function returned: ~answer~")
    }
}
```

================================================================================
7. STRING INTERPOLATION
================================================================================

Embed variable values in strings using ~variableName~ syntax.

Syntax:
    speak("Text ~var1~ more text ~var2~")

Examples:

Example 1: Simple Interpolation
    name <> "Katie"
    age <> 25
    speak("My name is ~name~ and I am ~age~ years old")

    Output: "My name is Katie and I am 25 years old"

Example 2: With Calculations
    x <> 10
    y <> 20
    sum <> calc(x, y)
    speak("~x~ + ~y~ = ~sum~")

    Output: "10 + 20 = 30"

Example 3: With Math Solutions
    result([24]) <> randomChoice([3, 8])
    speak("The answer is ~result~")

    Output: "The answer is 24"

================================================================================
8. COMPLETE EXAMPLES
================================================================================

8.1 Example: Hello World
-------------------------
File: hello.slut

```
* <main> HelloWorld {
    ^ observe_execution {
        speak("Hello, Quantum Consciousness!")
        speak("Welcome to the .slut programming language")
    }
}
```

8.2 Example: User Interaction
------------------------------
File: greeting.slut

```
* <main> Greeting {
    ^ observe_execution {
        name <> userIn("What is your name?")
        age <> userIn("What is your age?")

        speak("Hello, ~name~!")
        speak("You are ~age~ years old")

        years <> calc(age, 10)
        speak("In 10 years, you will be ~years~")
    }
}
```

8.3 Example: Math Puzzle Solver
--------------------------------
File: puzzle.slut

```
* <main> MathPuzzle {
    ^ observe_execution {
        speak("Solving: Find 24 using [3, 8, 3]")

        solution([24]) <> randomChoice([3, 8, 3])

        speak("Found solution!")
        woof solution
    }
}
```

8.4 Example: Game of 24
------------------------
File: game_24.slut

```
* <main> Game24 {
    ^ observe_execution {
        speak("=== GAME OF 24 ===")
        speak("Try to make 24 from four numbers!")

        num1 <> randomChoice([1, 2, 3, 4, 5, 6, 7, 8, 9])
        num2 <> randomChoice([1, 2, 3, 4, 5, 6, 7, 8, 9])
        num3 <> randomChoice([1, 2, 3, 4, 5, 6, 7, 8, 9])
        num4 <> randomChoice([1, 2, 3, 4, 5, 6, 7, 8, 9])

        speak("Your numbers are: ~num1~, ~num2~, ~num3~, ~num4~")
        speak("Finding solution...")

        answer([24]) <> randomChoice([num1, num2, num3, num4])

        speak("Solution found!")
        woof answer
    }
}
```

8.5 Example: Building Blocks
-----------------------------
File: building_blocks.slut

```
* <main> BuildingBlocks {
    ^ observe_execution {
        speak("Building mathematical blocks...")

        # Find 12
        twelve([12]) <> randomChoice([3, 4])
        speak("Step 1: ~twelve~")

        # Find 24 using 12 and other numbers
        twentyfour([24]) <> randomChoice([twelve, 2])
        speak("Step 2: ~twentyfour~")

        # Find 100 using 24 and other numbers
        hundred([100]) <> randomChoice([twentyfour, 4])
        speak("Step 3: ~hundred~")

        woof hundred
    }
}
```

8.6 Example: Function Building
-------------------------------
File: build.slut

```
* <main> FunctionBuilder {
    ^ observe_execution {
        speak("Building shared functions...")

        # Create a loop function
        sharedLoop(params) <> function(loop)

        # Create a conditional function
        conditionalCheck(params) <> function(conditional)

        speak("Functions built!")

        # Test the loop
        sharedLoop(3)("console.log('Loop iteration')")

        speak("Functions tested successfully!")
    }
}
```

================================================================================
9. RUNNING YOUR PROGRAMS
================================================================================

9.1 Basic Execution
-------------------
Run a .slut file:

    cargo run -- yourfile.slut

Or if you've built the binary:

    quantum yourfile.slut

Example:
    cargo run -- hello.slut

9.2 Multiple Observations
--------------------------
Run the same program multiple times (useful for learning/caching):

    cargo run -- yourfile.slut --observations 3

This will:
- Run the program 3 times
- Cache solutions between runs
- Each run can build on previous solutions

Example:
    cargo run -- puzzle.slut --observations 5

9.3 Interactive Mode
--------------------
Launch the interactive mathematical reasoning engine:

    cargo run -- --interactive

This provides:
- REPL-like interface
- Solve math puzzles interactively
- Solutions are cached and used as building blocks
- Beautiful colored CLI with progress indicators

Interactive commands:
- Enter a target number
- Enter available numbers (comma-separated)
- Use '?' for blanks (system fills with cached solutions)
- Type 'help' for instructions
- Type 'stats' to see session statistics
- Type 'quit' to exit

Example session:
```
>> Enter target number: 24
>> Enter available numbers: 3,4,2
>> Analyzing problem...
== SOLUTION FOUND!
   Equation: 3 * 4 * 2
   Result: 24
```

9.4 Building the Project
-------------------------
Before first run, build the project:

    cargo build

For optimized release build:

    cargo build --release
    ./target/release/quantum yourfile.slut

9.5 Running Tests
-----------------
If tests are added in the future:

    cargo test

================================================================================
10. TIPS AND BEST PRACTICES
================================================================================

10.1 Naming Conventions
-----------------------
- Use descriptive variable names: `targetScore` not `x`
- Use PascalCase for class names: `MathSolver`
- Use camelCase for variable names: `myVariable`

10.2 Math Solving
-----------------
- Start with fewer numbers (2-3) for faster solving
- Use cached solutions as building blocks
- Run with --observations to build up a solution cache
- The system finds exact matches first, then approximations

10.3 Debugging
--------------
- Use speak() to print intermediate values
- Use woof to see the source equation of a variable
- Check the console output for solution accuracy percentages
- Use interactive mode to test math problems

10.4 Performance
----------------
- Math solving is parallelized (uses all CPU cores)
- Solutions are cached for reuse
- Generated functions are written to disk
- Multiple observations build up the cache

10.5 File Organization
----------------------
- One main class per file
- Use separate .slut files for different programs
- Keep example numbers small for faster solving
- Comment your code with # (if supported in future)

10.6 Common Patterns
--------------------

Pattern 1: Progressive Building
    step1([10]) <> randomChoice([2, 5])
    step2([20]) <> randomChoice([step1, 2])
    step3([100]) <> randomChoice([step2, 5])

Pattern 2: User-Driven Math
    target <> userIn("Enter target number")
    num1 <> userIn("Enter first number")
    num2 <> userIn("Enter second number")
    solution([target]) <> randomChoice([num1, num2])

Pattern 3: Random Puzzle Generation
    a <> randomChoice([1, 2, 3, 4, 5])
    b <> randomChoice([1, 2, 3, 4, 5])
    c <> randomChoice([1, 2, 3, 4, 5])
    answer([24]) <> randomChoice([a, b, c])

================================================================================
QUICK REFERENCE
================================================================================

Syntax Summary:
---------------
* <main> ClassName { ^ observe_execution { ... } }   # Main program structure
* FunctionName { ^ observe_execution { ... } }       # Function class
speak("message")                                     # Print output
speak("text ~var~ text")                             # String interpolation
woof variable                                        # Print variable + source
var <> value                                         # Assignment
var <> userIn("prompt")                              # User input
var <> calc(n1, n2, ...)                            # Addition
var <> randomChoice([opt1, opt2, ...])              # Random selection
var([target]) <> randomChoice([nums])                # Math solving
funcName(params) <> function(type)                   # Define function
funcName(params)("body")                             # Execute function

Command Summary:
----------------
cargo run -- file.slut                               # Run a program
cargo run -- file.slut --observations N              # Run N times
cargo run -- --interactive                           # Interactive mode
cargo build                                          # Build project
cargo build --release                                # Optimized build

================================================================================
EXAMPLES DIRECTORY
================================================================================

The following example files are included:

- build.slut         : Function building example
- consumer.slut      : Using functions from other programs
- (create your own!) : Try the examples from Section 8

================================================================================
TROUBLESHOOTING
================================================================================

Problem: "No main class found"
Solution: Make sure you have `* <main> ClassName` in your file

Problem: Math solver can't find exact solution
Solution: Try simpler numbers, or accept the approximation shown

Problem: Variable not found
Solution: Ensure the variable is defined before use with `<>`

Problem: Syntax error
Solution: Check that all braces {} are matched and statements use correct syntax

Problem: Slow performance
Solution: Use fewer/smaller numbers, or run with --release build

================================================================================
ADVANCED TOPICS
================================================================================

For advanced features, see:
- Improvement_Plan.txt : Future enhancements and optimizations
- Source code in src/ : Implementation details
- functions/src/      : Generated function code

Phase 1 improvements include:
- Parallel equation solving (3-10x faster)
- Advanced expression parsing
- Colored interactive CLI
- Progress indicators
- Structured logging

================================================================================
SUPPORT AND COMMUNITY
================================================================================

For questions, issues, or contributions:
- Check the GitHub repository
- Review the source code documentation
- Experiment in interactive mode
- Study the example .slut files

Happy Quantum Consciousness Programming!

================================================================================
END OF SLUT 101
================================================================================
