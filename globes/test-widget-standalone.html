<!DOCTYPE html>
<html>
<head>
    <title>OOP Sphere Visualizer Test</title>
    <style>
        body { 
            margin: 0; 
            font-family: monospace; 
            background: #1e1e1e; 
            color: white;
            overflow: hidden;
        }
        #container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        #header {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #4a90e2;
        }
        #sphere-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h3 style="margin: 0; color: #4a90e2;">üêç OOP Sphere Visualizer</h3>
            <p style="margin: 5px 0; font-size: 12px; color: #aaa;">Interactive 3D visualization for Object-Oriented Programming</p>
        </div>
        <div id="sphere-container"></div>
    </div>
    
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Load Skulpt -->
    <script src="https://unpkg.com/skulpt@0.11.1/dist/skulpt.min.js"></script>
    <script src="https://unpkg.com/skulpt@0.11.1/dist/skulpt-stdlib.js"></script>
    
    <script>
        // Wait for libraries to load, then initialize
        function initSphereVisualization() {
            const container = document.getElementById('sphere-container');
            
            // Basic Three.js scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Create the main sphere
            const geometry = new THREE.SphereGeometry(3, 64, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x4a90e2,
                transparent: true, 
                opacity: 0.3
            });
            
            const sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            
            // Add wireframe
            const wireGeometry = new THREE.SphereGeometry(3.01, 32, 16);
            const wireMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x666666, 
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });
            const wireframe = new THREE.Mesh(wireGeometry, wireMaterial);
            scene.add(wireframe);
            
            // Add sample OOP nodes
            const nodeColors = {
                'function': 0xffc107,   // Yellow
                'condition': 0x9c27b0,  // Purple  
                'loop': 0xf44336,       // Red
                'class': 0x2196f3,      // Blue
                'single': 0x9e9e9e      // Gray
            };
            
            const nodeTypes = Object.keys(nodeColors);
            const nodes = [];
            
            // Create nodes using golden spiral distribution
            for (let i = 0; i < 12; i++) {
                const phi = Math.acos(-1 + (2 * i) / 12);
                const theta = Math.sqrt(12 * Math.PI) * phi;
                
                const x = Math.cos(theta) * Math.sin(phi) * 3.2;
                const y = Math.sin(theta) * Math.sin(phi) * 3.2;
                const z = Math.cos(phi) * 3.2;
                
                const nodeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const nodeType = nodeTypes[i % nodeTypes.length];
                const nodeMaterial = new THREE.MeshPhongMaterial({ 
                    color: nodeColors[nodeType],
                    shininess: 100
                });
                
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                node.position.set(x, y, z);
                node.userData = { type: nodeType };
                scene.add(node);
                nodes.push(node);
            }
            
            // Mouse controls
            let mouseDown = false;
            let mousePos = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mousePos = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const deltaX = e.clientX - mousePos.x;
                    const deltaY = e.clientY - mousePos.y;
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    mousePos = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                const delta = e.deltaY > 0 ? 0.3 : -0.3;
                spherical.radius = Math.max(1.5, Math.min(15, spherical.radius + delta));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            });
            
            // Animation loop
            const animate = () => {
                requestAnimationFrame(animate);
                
                // Slow rotation
                sphere.rotation.y += 0.005;
                wireframe.rotation.y += 0.005;
                
                // Gentle node movement
                nodes.forEach((node, i) => {
                    node.rotation.x += 0.01;
                    node.rotation.y += 0.02;
                });
                
                renderer.render(scene, camera);
            };
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            console.log('üåê OOP Sphere Visualizer initialized successfully!');
            console.log('üéÆ Controls: Drag to rotate, scroll to zoom');
        }
        
        // Start when page loads
        window.addEventListener('load', () => {
            setTimeout(initSphereVisualization, 100);
        });
    </script>
</body>
</html>